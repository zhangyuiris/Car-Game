<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ğŸš‡</title>
  <script src="js/stats.js"></script>
  <script src="js/three.min.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/THREEx.KeyboardState.js"></script>
  <script src="js/CSG.js"></script>
  <style>
    body {
      padding: 0;
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin:0 auto;
    }
    .fps {
      position: fixed;
      z-index: 999;
      left: 0;
      top: 0;
    }
  </style>
</head>
<body>
  <div id="ThreeJS" style="z-index: 2;"></div>
  <div id="Stats-output"></div>
<script>
  // å®šä¹‰å…¨å±€å˜é‡
  let container, scene, camera, renderer, controls;
  let keyboard = new THREEx.KeyboardState();
  let clock = new THREE.Clock;
  let stats;
  let movingCube;
  let collideMeshList = [];
  let cubes = [];
  let crash = false;
  let id = 0;
  let score = 0;
  let crashId = " ";
  let lastCrashId = " ";
  init();
  animate();
  
  function init() {
    // Scene
    scene = new THREE.Scene();
    // Camera
    let screenWidth = window.innerWidth;
    let screenHeight = window.innerHeight;
    camera = new THREE.PerspectiveCamera(45, screenWidth/screenHeight, 0.1, 5000);
    camera.position.set(0, 100, 400);
    
    // renderer
    renderer = new THREE.WebGLRenderer({
      antialias: true,
      logarithmicDepthBuffer: true
    });
    
    // å¤©çš„é¢œè‰²
    renderer.setClearColor(new THREE.Color(0x69c6d0));
    renderer.setSize(screenWidth, screenHeight);
    renderer.shadowMap.enabled = true;
    
    container = document.getElementById("ThreeJS");
    container.appendChild(renderer.domElement);
    
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    
    // åŠ å…¥åœ°é¢
    let floorMaterial = new THREE.MeshBasicMaterial({
      color: 0x222222,
      side: THREE.DoubleSide
    });
    let floorGeometry = new THREE.PlaneGeometry(600, 10000, 10, 10);
    let floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = Math.PI / 2;
    scene.add(floor);
  
    // å…‰çº¿
    let ambientLight = new THREE.AmbientLight(0xffffff);
    ambientLight.name = "Ambient Light";
    scene.add(ambientLight);
    
    let hemiLight = new THREE.HemisphereLight(0x0044ff, 0xffffff, 0.5);
    hemiLight.name = "Hemisphere Light";
    hemiLight.position.set(0,5,0);
    scene.add(hemiLight);
  
    var cubeGeometry = new THREE.SphereGeometry(25, 10, 10);
    var wireMaterial = new THREE.MeshBasicMaterial({
      color: 0xffe411
    });
    movingCube = new THREE.Mesh(cubeGeometry, wireMaterial);
    movingCube.position.set(0, 25, 0);
    scene.add(movingCube);
    
    // stats
    stats = initStats();
  }
  
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    update();
  }
  
  function update() {
    stats.update();
    controls.update();
    let delta = clock.getDelta();
    let moveDistance = 200 * delta;
    let rotateAngle = Math.PI / 2 * delta;
    if (keyboard.pressed("left")) {
      if (movingCube.position.x > -270)
        movingCube.position.x -= moveDistance;
      if (camera.position.x > -150) {
        camera.position.x -= moveDistance * 0.6;
        if (camera.rotation.z > -5 * Math.PI / 180) {
          camera.rotation.z -= 0.2 * Math.PI / 180;
        }
      }
    }
    if (keyboard.pressed("right")) {
      if (movingCube.position.x < 270)
        movingCube.position.x += moveDistance;
      if (camera.position.x < 150) {
        camera.position.x += moveDistance * 0.6;
        if (camera.rotation.z < 5 * Math.PI / 180) {
          camera.rotation.z += 0.2 * Math.PI / 180;
        }
      }
    }
    if (keyboard.pressed("A")) {
      movingCube.rotation.y -= rotateAngle;
    }
    if (keyboard.pressed("D")) {
      movingCube.rotation.y += rotateAngle;
    }
    if (keyboard.pressed("up") || keyboard.pressed("W")) {
      movingCube.position.z -= moveDistance;
    }
    if (keyboard.pressed("down") || keyboard.pressed("S")) {
      movingCube.position.z += moveDistance;
    }
    // threejsçš„å‡ ä½•ä½“é»˜è®¤æƒ…å†µä¸‹å‡ ä½•ä¸­å¿ƒåœ¨åœºæ™¯ä¸­åæ ‡æ˜¯åæ ‡åŸç‚¹ã€‚
    // å¯ä»¥é€šè¿‡positionå±æ€§æˆ–.getWorldPosition()æ–¹æ³•è·å¾—æ¨¡å‹å‡ ä½•ä¸­å¿ƒçš„ä¸–ç•Œåæ ‡
    let originPoint = movingCube.position.clone();
    //çƒä½“ç½‘æ ¼æ¨¡å‹å‡ ä½•ä½“çš„æ‰€æœ‰é¡¶ç‚¹æ•°æ®
    let vertices = movingCube.geometry.vertices
    for (let vertexIndex = 0; vertexIndex < movingCube.geometry.vertices.length; vertexIndex++) {
      // é¡¶ç‚¹åŸå§‹åæ ‡
      let localVertex = vertices[vertexIndex].clone();
      // é¡¶ç‚¹ç»è¿‡å˜æ¢åçš„åæ ‡
      // vertices[i]è·å¾—å‡ ä½•ä½“ç´¢å¼•æ˜¯içš„é¡¶ç‚¹åæ ‡ï¼Œ
      // æ³¨æ„æ‰§è¡Œ.clone()è¿”å›ä¸€ä¸ªæ–°çš„å‘é‡ï¼Œä»¥å…æ”¹å˜å‡ ä½•ä½“é¡¶ç‚¹åæ ‡å€¼
      // å‡ ä½•ä½“çš„é¡¶ç‚¹åæ ‡è¦æ‰§è¡Œè¯¥å‡ ä½•ä½“ç»‘å®šæ¨¡å‹å¯¹è±¡ç»è¿‡çš„æ—‹è½¬å¹³ç§»ç¼©æ”¾å˜æ¢
      // å‡ ä½•ä½“é¡¶ç‚¹ç»è¿‡çš„å˜æ¢å¯ä»¥é€šè¿‡æ¨¡å‹çš„æœ¬åœ°çŸ©é˜µå±æ€§.matrixæˆ–ä¸–ç•ŒçŸ©é˜µå±æ€§.matrixWorldè·å¾—
      let globalVertex = localVertex.applyMatrix4(movingCube.matrix);
      // è·å¾—ç”±ä¸­å¿ƒæŒ‡å‘é¡¶ç‚¹çš„å‘é‡
      let directionVector = globalVertex.sub(movingCube.position);
      // å°†æ–¹å‘å‘é‡åˆå§‹åŒ–,å¹¶å‘å°„å…‰çº¿
      // Ray casteræ„é€ å‡½æ•°åˆ›å»ºä¸€ä¸ªå°„çº¿æŠ•å°„å™¨å¯¹è±¡ï¼Œå‚æ•°1ã€å‚æ•°2æ”¹å˜çš„æ˜¯è¯¥å¯¹è±¡çš„å°„çº¿å±æ€§.ray
      // å‚æ•°1ï¼šå°„çº¿çš„èµ·ç‚¹
      // å‚æ•°2ï¼šå°„çº¿çš„æ–¹å‘ï¼Œæ³¨æ„å½’ä¸€åŒ–çš„æ—¶å€™ï¼Œéœ€è¦å…ˆå…‹éš†,å¦åˆ™åé¢ä¼šæ‰§è¡Œdir.length()è®¡ç®—å‘é‡é•¿åº¦ç»“æœæ˜¯1
      let ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
      // æ£€æµ‹å°„çº¿ä¸å¤šä¸ªç‰©ä½“çš„ç›¸äº¤æƒ…å†µ
      // å¦‚æœä¸ºtrueï¼Œå®ƒè¿˜æ£€æŸ¥æ‰€æœ‰åä»£ã€‚å¦åˆ™åªæ£€æŸ¥è¯¥å¯¹è±¡æœ¬èº«ã€‚ç¼ºçœå€¼ä¸ºfalse
      let collisionResults = ray.intersectObjects(collideMeshList, true);
      // å¦‚æœè¿”å›ç»“æœä¸ä¸ºç©ºï¼Œä¸”äº¤ç‚¹ä¸å°„çº¿èµ·ç‚¹çš„è·ç¦»å°äºç‰©ä½“ä¸­å¿ƒè‡³é¡¶ç‚¹çš„è·ç¦»ï¼Œåˆ™å‘ç”Ÿäº†ç¢°æ’
      // intersects[0].distanceï¼šå°„çº¿èµ·ç‚¹ä¸äº¤å‰ç‚¹ä¹‹é—´çš„è·ç¦»(äº¤å‰ç‚¹ï¼šå°„çº¿å’Œæ¨¡å‹è¡¨é¢äº¤å‰ç‚¹åæ ‡)
      // dir.length()ï¼šçƒä½“é¡¶ç‚¹å’Œçƒä½“å‡ ä½•ä¸­å¿ƒæ„æˆå‘é‡çš„é•¿åº¦
      // é€šè¿‡è·ç¦»å¤§å°æ¯”è¾ƒåˆ¤æ–­æ˜¯å¦ç¢°æ’
      // intersects[0].distanceå°äºdir.length()ï¼Œè¯´æ˜äº¤å‰ç‚¹çš„ä½ç½®åœ¨å°„çº¿èµ·ç‚¹å’Œçƒä½“å‡ ä½•ä½“é¡¶ç‚¹ä¹‹é—´ï¼Œ
      // è€Œäº¤å‰ç‚¹åˆåœ¨ç«‹æ–¹ä½“è¡¨é¢ä¸Š,ä¹Ÿå°±æ˜¯è¯´ç«‹æ–¹ä½“éƒ¨åˆ†è¡¨é¢æ’å…¥åˆ°äº†çƒä½“é‡Œé¢
      if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
        crash = true;
        crashId = collisionResults[0].object.name;
        break;
      }
      crash = false;
    }
    // è®¡ç®—é‡
    // é€šè¿‡ä¸Šé¢çš„ä»£ç ä½ å¯ä»¥çœ‹åˆ°
    // å¦‚æœè¦åˆ¤æ–­ä¸€ä¸ªç½‘æ ¼æ¨¡å‹å’Œå¦ä¸€ä¸ªç½‘æ ¼æ¨¡å‹æ˜¯å¦ç¢°æ’
    // éœ€è¦å¾ªç¯éå†è¯¥æ¨¡å‹ç»‘å®šå‡ ä½•ä½“Geometryçš„æ‰€æœ‰é¡¶ç‚¹ä½ç½®åæ ‡
    // ç„¶ååˆ†åˆ«åˆ›å»ºä¸€ä¸ªå°„çº¿
    // ç„¶åæŠŠåˆ›å»ºçš„å°„çº¿ä¸å…¶å®ƒç½‘æ ¼æ¨¡å‹è¿›è¡Œå°„çº¿æ‹¾å–äº¤å‰è®¡ç®—
    // è¿™ä¹Ÿå°±æ˜¯è¯´è¯¥æ¨¡å‹å‡ ä½•ä½“çš„é¡¶ç‚¹æ•°é‡é˜…è¯»
    // è®¡ç®—é‡è¶Šå¤§ã€‚
    if (crash) {
      movingCube.material.color.setHex(0x346386);
      console.log("Crash");
      if (crashId !== lastCrashId) {
        score -= 100;
        lastCrashId = crashId;
      }
    } else {
      movingCube.material.color.setHex(0xffe411);
    }
    if (Math.random() < 0.03 && cubes.length < 30) {
      makeRandomCar();
    }
    for (i = 0; i < cubes.length; i++) {
      if (cubes[i].position.z > camera.position.z) {
        scene.remove(cubes[i]);
        cubes.splice(i, 1);
        collideMeshList.splice(i, 1);
      } else {
        cubes[i].position.z += 10;
      }
    }
  }
  
  function makeRandomCar() {
    let color = getRandomInt(0x171717, 0xcccccc);
    let name = "car_" + id;
    id++;
    // mess åˆå§‹åŒ–
    let mess = new THREE.Object3D();
    mess.name = name;
    // thuck åˆå§‹åŒ– position
    let a = getRandomArbitrary(-250, 250);
    let b = 30;
    let c = getRandomArbitrary(-800, -1200);
    mess.position.set(a, b, c);
    scene.add(mess);
    cubes.push(mess);
    collideMeshList.push(mess);
    // Body
    let truckBodyBase = new THREE.Mesh(new THREE.BoxGeometry(50,40,100));
    let cutFront = new THREE.Mesh(new THREE.BoxGeometry(50,15,25));
    let cutBack = new THREE.Mesh(new THREE.BoxGeometry(50,15,45));
    // ä¸Šåº•åŠå¾„ ä¸‹åº•åŠå¾„ é«˜åº¦ åœ†æŸ±å‘¨å›´çš„åˆ†æ®µé¢æ•° æ²¿ç€åœ†æŸ±é«˜åº¦çš„é¢çš„è¡Œæ•°
    let frontTireHoles = new THREE.Mesh(new THREE.CylinderGeometry(12,12,50,16,16,false));
    let backTireHoles = frontTireHoles.clone();
    let trunk = new THREE.Mesh(new THREE.BoxGeometry(44,15,40));

    cutFront.position.set(0,12.5,-37.5);
    cutBack.position.set(0,12.5,30);

    frontTireHoles.position.set(0, -20, -30);
    frontTireHoles.rotation.z = 90 * Math.PI/180;

    backTireHoles.position.set(0, -20, 30);
    backTireHoles.rotation.z = frontTireHoles.rotation.z;

    trunk.position.set(0, 1, 27.5);

    truckBodyBase.updateMatrix();
    cutFront.updateMatrix();
    cutBack.updateMatrix();
    frontTireHoles.updateMatrix();
    backTireHoles.updateMatrix();
    trunk.updateMatrix();

    let truckBodyBase_BSP = CSG.fromMesh(truckBodyBase);
    let cutFront_BSP = CSG.fromMesh(cutFront);
    let cutBack_BSP = CSG.fromMesh(cutBack);
    let frontTireHoles_BSP = CSG.fromMesh(frontTireHoles);
    let backTireHoles_BSP = CSG.fromMesh(backTireHoles);
    let trunk_BSP = CSG.fromMesh(trunk);
    let truckBody_BSP = truckBodyBase_BSP
        .subtract(cutFront_BSP)
        .subtract(cutBack_BSP)
        .subtract(frontTireHoles_BSP)
        .subtract(backTireHoles_BSP)
        .subtract(trunk_BSP);
    let truckBody = CSG.toMesh(truckBody_BSP, truckBodyBase.matrix);

    truckBody.material = new THREE.MeshLambertMaterial({
      color: color
    });
    truckBody.position.set(0,0.5,0);
    truckBody.castShadow = true;
    mess.add(truckBody);

    // Wheels
    let wheelGeo = new THREE.CylinderGeometry(10, 10, 5, 24, 24, false);
    let wheelMat = new THREE.MeshLambertMaterial({
      color: 0x171717
    });
    let wheel = new THREE.Mesh(wheelGeo,wheelMat);
    wheel.castShadow = true;
    wheel.rotation.z = -0.5 * Math.PI;

    let wheelPos = [
      {x: -22.5, y: -15, z: 30, name: "BL"},
      {x: 22.5, y: -15, z: 30, name: "BR"},
      {x: -22.5, y: -15, z: -30, name: "FL"},
      {x: 22.5, y: -15, z: -30, name: "FR"}
    ];
    for (let p of wheelPos) {
      var w = wheel.clone();
      w.name = p.name;
      w.position.set(p.x,p.y,p.z);
      mess.add(w);
    }
    // IV. Windows
    let windowMat = new THREE.MeshLambertMaterial({
      color: 0x171717
    });

		let	horzWindowGeo = new THREE.PlaneBufferGeometry(44, 12);
		let	horzWindowMat = windowMat;
		let	horzWindow = new THREE.Mesh(horzWindowGeo,horzWindowMat);

		let	midFrontWindowGeo = new THREE.PlaneBufferGeometry(14, 12);
		let	midFrontWindowMat = windowMat;
		let	midFrontWindow = new THREE.Mesh(midFrontWindowGeo,midFrontWindowMat);

		let	midBackWindowGeo = new THREE.PlaneBufferGeometry(10, 12);
	  let	midBackWindowMat = windowMat;
		let	midBackWindow = new THREE.Mesh(midBackWindowGeo,midBackWindowMat);

		horzWindow.receiveShadow = true;
    midFrontWindow.receiveShadow = true;
    midBackWindow.receiveShadow = true;

    let leftMFWindow = midFrontWindow.clone();
    leftMFWindow.position.set(-25.1, 15.5, -15.5);
    leftMFWindow.rotation.y = -0.5 * Math.PI;
    mess.add(leftMFWindow);

    let rightMFWindow = midFrontWindow.clone();
    rightMFWindow.position.set(25.1, 15.5,-15.5);
    rightMFWindow.rotation.y = 0.5 * Math.PI;
    mess.add(rightMFWindow);

    let leftMBWindow = midBackWindow.clone();
    leftMBWindow.position.set(-25.1, 15.5, -0.5);
    leftMBWindow.rotation.y = -0.5 * Math.PI;
    mess.add(leftMBWindow);

    let rightMBWindow = midBackWindow.clone();
    rightMBWindow.position.set(25.1, 15.5,-0.5);
    rightMBWindow.rotation.y = 0.5 * Math.PI;
    mess.add(rightMBWindow);

    let frontWindow = horzWindow.clone();
    frontWindow.position.set(0, 15.5, -25.1);
    frontWindow.rotation.y = Math.PI;
    mess.add(frontWindow);

    let backWindow = horzWindow.clone();
    backWindow.position.set(0, 15.5, 7.6);
    mess.add(backWindow);

    /// V. Lights
    let lightGeo = new THREE.PlaneBufferGeometry(7.5, 10);
    let frontLightMat = new THREE.MeshLambertMaterial({
      color: 0xf1f1f1
    });
    let frontLight = new THREE.Mesh(lightGeo,frontLightMat);
    let backLightMat = new THREE.MeshLambertMaterial({
      color: 0xf65555
    });
    let backLight = new THREE.Mesh(lightGeo,backLightMat);

    frontLight.rotation.y = Math.PI;

    let frontLeftLight = frontLight.clone();
    frontLeftLight.position.set(-21.25, 2.5, -50.1);
    mess.add(frontLeftLight);

    let frontRightLight = frontLight.clone();
    frontRightLight.position.set(21.25, 2.5, -50.1);
    mess.add(frontRightLight);

    let backLeftLight = backLight.clone();
    backLeftLight.position.set(-21.25, 2.5, 50.1);
    mess.add(backLeftLight);

    let backRightLight = backLight.clone();
    backRightLight.position.set(21.25, 2.5, 50.1);
    mess.add(backRightLight);
  }
  function initStats() {
    var stats = new Stats();
    //è®¾ç½®ç»Ÿè®¡æ¨¡å¼
    stats.setMode(0); // 0: fps, 1: ms
    //å°†ç»Ÿè®¡å¯¹è±¡æ·»åŠ åˆ°å¯¹åº”çš„<div>å…ƒç´ ä¸­
    stats.domElement.style.position = 'fixed';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    document.getElementById("Stats-output").appendChild(stats.domElement);
    return stats;
  }

  // è¿”å›ä¸€ä¸ªä»‹äºminå’Œmaxä¹‹é—´çš„éšæœºæ•°
  function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
  }

  // è¿”å›ä¸€ä¸ªä»‹äºminå’Œmaxä¹‹é—´çš„æ•´å‹éšæœºæ•°
  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
</script>
</body>
</html>
